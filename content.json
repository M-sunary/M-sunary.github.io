[{"title":"Linux系统下crontab配置","date":"2018-01-30T11:17:57.000Z","path":"2018/01/30/Linux系统下crontab配置/","text":"背景 APP与经代通共用GW代码，经代通同学每次发布GW服务会在consul注册服务，之后APP的服务调用GW服务时，DSF会在consul中查找GW服务，有几率会调用到经代通注册的GW服务，由于GW后期代码不一致，导致服务异常。如下图： cron服务简介 cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业。在LINUX中，周期执行的任务一般由cron这个守护进程来处理[ps -ef|grep cron]。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为“crontab”，是“cron table”的简写。 crontab配置 crontab命令用于安装、删除或者列出用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行。每个用户都可以有自己的crontab文件。/var/spool/cron下的crontab文件不可以直接创建或者直接修改。该crontab文件是通过crontab命令创建的。 在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。 格式如下： minute hour day-of-month month-of-year day-of-week commands 00-59 00-23 01-31 01-12 0-6 (0 is sunday) 实例1：每晚的21:30重启web服务命令：30 21 * sh /alidata1/admin/hq-esell-web/bin/startup.sh 实例2：每月1、10、22日的4 : 45重启web服务 命令： 45 4 1,10,22 sh /alidata1/admin/hq-esell-web/bin/startup.sh 实例3：每周六、周日的1 : 10重启web服务 命令： 10 1 6,0 sh /alidata1/admin/hq-esell-web/bin/startup.sh 实例4：每天18 : 00至23 : 00之间每隔30分钟重启web服务 命令 0,30 18-23 * sh /alidata1/admin/hq-esell-web/bin/startup.sh 实例5：每30分钟执行一次 命令 /30 * python /alidata1/admin/script/clear_dsf.py 12345678910111213141516171819202122-除了数字还有几个个特殊的符号就是&quot;*&quot;、&quot;/&quot;和&quot;-&quot;、&quot;,&quot;。 =&gt; &quot;*&quot;代表所有的取值范围内的数字, =&gt; &quot;/&quot;代表每的意思, =&gt; &quot;/5&quot;表示每5个单位, =&gt; &quot;-&quot;代表从某个数字到某个数字, =&gt; &quot;,&quot;分开几个离散的数字。*: crontab服务的重启关闭，开启mac: sudo /usr/sbin/cron start sudo /usr/sbin/cron restart sudo /usr/sbin/cron stopubuntu: sudo /etc/init.d/cron start sudo /etc/init.d/cron stop sudo /etc/init.d/cron restartlinux: service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 service crond status //查看服务状态","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"Linux服务器别名配置","date":"2018-01-22T14:05:48.000Z","path":"2018/01/22/Linux服务器别名配置/","text":"背景 最近一段时间频繁的配合测试查看服务器日志，抽取业务报文，个人觉得目前使用起来效率有点低下，结合切身体会，做了一点点优化，分享给大家，希望也能帮助到你们。痛点：每次上服务器查看业务日志或者抽取业务报文，总会输入冗长的日志路径，偶尔忙起来可能暂时忘了路径（反正我有过类似的经历，不知道大家有没有经历过）. 解决方法： 通过配置查看日志命令的别名(.aliases)，以达到 仅需记住简短的命令名称 即可 查看想要的业务日志。 linux 上别名配置 1234567891011121314151617181920212223242526272829303132333435exam：#web日志alias web-log='vim /alidata1/admin/hq-esell-web/logs/hq-esell-web.log'alias web-log-n='vim /alidata1/admin/hq-esell-web/logs/nohup.out'#apply日志alias apply-log='vim /alidata1/admin/hq-ins-apply/logs/hq-ins-apply.log'alias apply-log-n='vim /alidata1/admin/hq-ins-apply/logs/nohup.out.log'#gw日志alias gw-log='vim /alidata1/admin/hq-esell-gw/logs/hq-esell-gw.log'alias gw-log-n='vim /alidata1/admin/hq-esell-gw/logs/nohup.out'别名配置后，变化如下：'vim /alidata1/admin/hq-esell-gw/logs/hq-esell-gw.log' ==&gt;&gt; gw-log'vim /alidata1/admin/hq-esell-gw/logs/nohup.out' ==&gt;&gt; gw-log-n 之前冗长的命令，变成了 gw-log 和 gw-log-n.同理查看其它应用的业务日志，只须将 'gw' 换成 其它应用的关键字，如 'apply-log' 和 'apply-log-n'.如果这样，大家还是记不住命令名字那也没关系，我们只要输入命令的关键字 然后 按 'Tab键'就能联想出来我们已经配置的命令别名。另外还配置了两个路径,大家之后肯定会用到app静态资源文件路径 和 产品配置文件，所以命令配置如下：#静态资源-产品缩略图 大图等配置文件路径alias static-path='cd /alidata1/admin/hq-static/product &amp;&amp; echo 恭喜您，已进入静态资源根目录。需要注意文件的权限哦~！'#险种配置文件 根目录alias prod-config='cd /alidata1/admin/hq/product &amp;&amp; echo 恭喜您，已进入产品配置文件根目录。需要注意文件的权限哦~！'","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"我们没有在一起","date":"2017-11-27T03:37:44.000Z","path":"2017/11/27/我们没有在一起/","text":"我们没有在一起 - 刘若英词：黄婷曲：陈韦伶 你一直说的那个公园已经拆了还记得荡着秋千日子就飞起来慢慢的下午阳光都在脸上撒野你那傻气我只是想念那时候小小的你还没学会叹气谁又会想到他们现在喊我女王你哈哈笑的样子倒是一点没变时间走了 谁还在等呢这杯咖啡忘了加糖真不是我那么伤感世界太复杂你说单纯很难我当然都明白 可是呀只有你曾陪我在最初的地方只有你才能了解我要的梦从来不大我们没有在一起至少还像情侣一样我痛得 疯得 伤得在你面前哭得最惨我知道你也不能带我回到那个地方你说你现在很好而且喜欢回忆很长我们没有在一起至少还像家人一样总是远远关心远远分享那条路走呀走呀走呀总要回家两只手握着晃呀晃呀舍不得放 你不知道吧后来后来我都在想跟你走吧管他去哪呀这杯咖啡忘了加糖真不是我那么伤感世界太复杂你说单纯很难我当然都明白 可是呀只有你曾陪我在最初的地方只有你才能了解我要的梦从来不大我们没有在一起至少还像情侣一样我痛得 疯得 伤得在你面前哭得最惨我知道你也不能带我回到那个地方你说你现在很好而且喜欢回忆很长我们没有在一起至少还像家人一样总是远远关心远远分享 可是呀只有你曾陪我在最初的地方只有你才能了解我要的梦从来不大我们没有在一起至少还像情侣一样我痛得 疯得 伤得在你面前哭得最惨我知道你也不能带我回到那个地方你说你现在很好而且喜欢回忆很长我们没有在一起至少还像家人一样总是远远关心远远分享我们没有在一起至少还像朋友一样你远远的关心其实更长","tags":[{"name":"随笔","slug":"随笔","permalink":"//sunary.siste/tags/随笔/"}]},{"title":"Mybatis注意事项","date":"2017-11-27T03:20:29.000Z","path":"2017/11/27/Mybaties注意事项/","text":"Mybatis注意事项 MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，resultType是直接表示返回类型的，resultMap则是对外部ResultMap的引用， 注意： resultType跟resultMap不能同时存在。 123456不正确写法：&lt;insert id=&quot;insertWechatLoginData&quot; parameterType=&quot;wechatLoginData&quot; &gt;正确写法：&lt;insert id=&quot;insertWechatLoginData&quot; parameterType=&quot;WechatLoginData&quot; &gt; 虽然不会报错，但是mybatis的规则是parameterType用类型，resultMap用id。","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"Git版本控制系统简介","date":"2017-11-27T03:08:47.000Z","path":"2017/11/27/Git版本控制系统简介/","text":"Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 linus：The stupid content tracker. 优点： 1.受网络约束小； 2.适合分布式，版本快速迭代的项目开发； 缺点： 1.代码保密性差(开发者可以获取完整版本库包括所有版本信息)； 2.想要熟练掌握的学习周期比较长 有兴趣的同学自己去看一下 背景故事。 集中式版本控制系统 vs 分布式版本控制系统 集中式版本控制系统 集中式版本控制系统，版本库集中存放在中央服务器(容灾性差) 对于网络的依赖较强 业务数据安全性高 分布式版本控制系统 分布式版本控制系统没有中央服务器的概念，每个开发者都拥有完整的版本库(容灾性强) 代码保密性差 以开发者个人为主体，更符合Geek精神 Git工作区、暂存区和版本库的概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 git基本操作 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 git常用命令清单 Git flow 12&quot;workflow&quot;或者&quot;flow&quot;，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。 图源地址：A successful Git branching model 参考资料： 廖雪峰的官方网站： https://www.liaoxuefeng.com 阮一峰的网络日志： http://www.ruanyifeng.com/","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"软件设计模式之-单例模式","date":"2017-03-26T08:51:25.000Z","path":"2017/03/26/软件设计模式之-单例模式/","text":"什么是单例模式？ 123456789单利模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。特点：（1）在任何情况下，单例类永远只有一个实例存在（2）单例需要有能力为整个系统提供这一唯一实例实际生活中的应用： 在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。 单例模式常见的实现方式饿汉模式：是指在方法调用前就创建实例，比较饥渴优点：饿汉模式实现的单例能保证是线程安全的。缺点：类加载的时候就需要实例化，提前占用系统资源以下是”饿汉模式”的实现代码：12345678910111213141516package com.suny.singletom;/** * 饿汉式单例模式的实现：方法调用前实例 */public class MySingleton &#123; private static MySingleton instance= new MySingleton(); public MySingleton()&#123;&#125; public static MySingleton getInstance()&#123; return instance; &#125;&#125; 以下是多线程中调用”饿汉式”实现的单例123456789101112131415161718package com.suny.singletom;public class MyThread extends Thread&#123; //负责打印单例被调用时的hashCode public void run()&#123; System.out.println(MySingleton.getInstance().hashCode()); &#125; public static void main(String[] args) &#123; MyThread[] mts = new MyThread[5];//创建5个线程去调用单例的实现 for(int i=0;i&lt;mts.length;i++)&#123; mts[i] = new MyThread(); &#125; for(int j=0;j&lt;mts.length;j++)&#123; mts[j].start(); &#125; &#125;&#125; 以下是在多线程中调用”饿汉式”单例的运行结果：12345493057941493057941493057941493057941493057941 从运行结果中可以看出，hashCode一致，多线程中调用的是同一个单例的对象，线程安全。 懒汉模式懒汉模式：是指在被调用时才去实例化对象，不紧不慢优点：被调用时才去创建实例，不会造成系统资源占用缺点：不能保证单例对象的线程安全，在多线程的系统中线程非安全，需要Double check locking(双重锁检查)来解决可能存在的线程安全问题 “懒汉式”单例实现如下：123456789101112131415package com.suny.singletom;public class MySingletonLazy &#123; private static MySingletonLazy instance = null; private MySingletonLazy()&#123;&#125; //\"懒汉式\"单例实现 public static MySingletonLazy getInstance()&#123; if(null == instance)&#123; instance = new MySingletonLazy(); &#125; return instance; &#125;&#125; 在多线程中运行”懒汉式”单例：12","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"Java中重写(Override)与重载(Overload)的区别","date":"2017-03-19T08:56:24.000Z","path":"2017/03/19/Java中重写-Override-与重载-Overload-的区别/","text":"重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 以上实例编译运行结果如下：12动物可以移动狗可以跑和走 在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。这是由于在编译阶段，只是检查参数的引用类型。然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。 思考以下例子：12345678910111213141516171819202122232425class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125; public void bark()&#123; System.out.println(\"狗可以吠叫\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 b.bark(); &#125;&#125; 以上实例编译运行结果如下：12345TestDog.java:30: cannot find symbolsymbol : method bark()location: class Animal b.bark(); ^ 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用当需要在子类中调用父类的被重写方法时，要使用super关键字。 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 以上实例编译运行结果如下：12动物可以移动狗可以跑和走 重载(Overload) 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 注意: 无法以返回值类型作为重载函数的区分标准。 实例: 1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(\"test3\"); return \"returntest3\"; &#125; public String test(String s,int a)&#123; System.out.println(\"test4\"); return \"returntest4\"; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); &#125;&#125; 重载和重写的区别： 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。 本文摘自菜鸟教程,各种语言入门挺不错的。","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"接下来的路","date":"2017-03-16T14:16:26.000Z","path":"2017/03/16/接下来的路/","text":"年前便打算好了，过完年过来办离职手续简历也写好了，静静的待在桌面 年后的工作挺忙的，总想手头上的事情弄完了，再走不喜欢留着烂摊子但是，活儿哪有完的时候是时候决定了. 有些事你现在不做，以后也不会做。不想年轻的时候太过于安稳，老了再四处奔波。 今年五一：云南 or 厦门 ？","tags":[{"name":"随笔","slug":"随笔","permalink":"//sunary.siste/tags/随笔/"}]},{"title":"终于等到你","date":"2017-03-13T14:30:27.000Z","path":"2017/03/13/终于等到你/","text":"时隔七年，我看到你了。我们算是翻篇了。谢谢~","tags":[{"name":"随笔","slug":"随笔","permalink":"//sunary.siste/tags/随笔/"}]},{"title":"我恋上这座城","date":"2017-02-27T15:00:44.000Z","path":"2017/02/27/我恋上这座城/","text":"2013.07.06我踏上了这座城，魔都。抱着一颗追寻初恋的心，因为我的初恋也在这里。时隔三年没见，我想她了，我想看看她。 然而来了也并没有勇气，去开口，去打扰她现在的生活。 心里想着等等吧等我在这座城里站稳了脚跟，等我能养活自己，也有能力养活她的时候 这一等，就是四个年头。她，结婚了。 四年，在这里除了养活自己 啥都没干。但是我喜欢上了这座城，因为在这里我能跟你呼吸一样的空气，尽管都是霾。 从我们分手 七年整了。我还想你。很想很想","tags":[{"name":"随笔","slug":"随笔","permalink":"//sunary.siste/tags/随笔/"}]},{"title":"Leetcode修炼之路-02","date":"2017-02-11T15:54:28.000Z","path":"2017/02/11/Leetcode修炼之路-02/","text":"题目：Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 题目大意：输入一个整型数字，取它的逆序输出（输入:123 ,要求输出为 321）提示：如果输入数字超出整型数范围( -2^15 到 2^15-1)，则返回 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.yu.sun.leetcode.palindrome;public class ReverseInteger &#123; /** * 解题思路： * 1.判断输入的数字是否小于0： * 将输入数字的绝对值 逆反，如果小于0，则逆反后乘以-1返回，大于0则直接返回； * 2.输入数字超出整型范围直接返回 0; * 取数字逆反思路： * a.判断输入的数字是几位数； * b.将输入数字的位数作为循环的基数digitSize， * 循环中取出输入数的每一位上的数字， * 假如输入的数字为:x = abcde ,五位数 * 则for循环如下： * for(int n=0;n&lt; digitSize(x);n++)&#123; * int baseDigit = x%(int)Math.pow(10,n+1)/Math.pow(10,n);//取得输入数字每一位上的数； * baseDigit * (int)Math.pow(10,digitSize(x)-n-1);//将取出的数字乘以10的(位数减n再减1)次方,循环从0开始的 * &#125; * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub int x = 123124; int numSize = 0; ReverseInteger reverseInteger = new ReverseInteger(); if(x&lt;Integer.MAX_VALUE &amp;&amp; x&gt;Integer.MIN_VALUE)&#123; numSize = reverseInteger.getDigitSize(x); int reverseX = reverseInteger.getDigitReverse(x, numSize); System.out.println(reverseX); &#125;else&#123; System.out.println(\"输入数字超出整型数范围，结果为：\"+0); &#125; &#125; public int getDigitReverse(int x,int numSize)&#123; int reverseX = 0; if(x&lt;0)&#123; for(int i=0;i&lt;numSize;i++)&#123; int baseDigit = 0; baseDigit = (int)((Math.abs(x) % (int)Math.pow(10, i+1)) / (int)Math.pow(10, i)); reverseX += (baseDigit * (int)Math.pow(10, numSize-i-1)); &#125; return reverseX*-1; &#125;else&#123; for(int i=0;i&lt;numSize;i++)&#123; int baseDigit = 0; baseDigit = (int)((x % (int)Math.pow(10, i+1)) / (int)Math.pow(10, i)); reverseX += (baseDigit * (int)Math.pow(10, numSize-i-1)); &#125; return reverseX; &#125; &#125; public int getDigitSize(int x)&#123; int digitSize = 0; while(x!=0)&#123; x /= 10; digitSize ++; &#125; return digitSize; &#125;&#125;","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"Leetcode修炼之路-01","date":"2017-02-09T16:33:27.000Z","path":"2017/02/10/Leetcode修炼之路-01/","text":"题目：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 题目大意：给定一个整数数组，返回数组中两个数的索引，使它们相加等于目标数。 示例： 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.yu.sun.leetcode.palindrome;import java.util.HashMap;import java.util.Map;/** * 给定一个整型数组 和 一个目标值， * 从数组中找出两个值相加等于目标值(Target)，返回这两个值的索引(Indices) * 思路： * step1:定义一个长度为2的数组来存储\"符合要求的数组索引\",该数组称作 结果集，int[] resultArr = new int[2]; * 定义一个map用来存放数组的值和索引，key = arr[index], value =index, * 这么做是为了利用map.containsKey()这个函数来找剩下的一个值 * step2:依次取出源数组sourceArr[]中的值，如果当前值 x 比目标值 target 小, * 则将当前值的索引放到结果集中,即resultArr[0] = i; * step3:在循环中利用map.containsKey()的函数找寻剩下另一个符合 target-nums[i]的值。 * step4:如果找到直接return,没找到继续循环，直至结束 * @author yu.sun * */public class IndicesToTarget &#123; public static void main(String[] args)&#123; int nums[] = &#123;3,2,4&#125;; int target = 7; IndicesToTarget indicesToTarget = new IndicesToTarget(); System.out.println(indicesToTarget.twoSum(nums, target)[0]); System.out.println(indicesToTarget.twoSum(nums, target)[1]); &#125; public int[] twoSum(int[] nums, int target) &#123; int[] retArr = new int[2]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(target - nums[i]))&#123; retArr[0] = i; retArr[1] = map.get(target - nums[i]); return retArr; &#125; map.put(nums[i], i); &#125; return retArr; &#125;&#125;","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"bash使用ssh实现免密码登陆","date":"2016-08-23T06:57:26.000Z","path":"2016/08/23/bash使用ssh实现免密码登陆/","text":"SSH免密码登录1 打开一个文件，如叫pf2 写入下面内容，把yu.sun 和 * 换成自己名字和密码。3 chmod 740 pf4 ./pf脚本如下，例如：1234567#!/usr/bin/expect -f#auto ssh loginset timeout 30spawn ssh yu.sun@127.0.0.1expect \"password:\"send \"***\\r\"interact 相关资料： http://www.ahlinux.com/shell/5797.html","tags":[{"name":"生计","slug":"生计","permalink":"//sunary.siste/tags/生计/"}]},{"title":"11年母校的足球场","date":"2015-08-09T17:27:06.000Z","path":"2015/08/10/11年母校的足球场/","text":"第一次这么想在一个地方留宿，谢谢你。谢谢马鞍山~","tags":[{"name":"瞬间","slug":"瞬间","permalink":"//sunary.siste/tags/瞬间/"}]}]